module ForwardCli.Db

open Argu
open dotenv.net
open Spectre.Console

open Forward
open Forward.MySql
open ForwardCli.OutputResult

// Internal "counts" type. This is useful for coercing the output of different
// count command branches so the F# compiler is appeased.
type Counts = { Label: string; Counts: string list }

// This is used by both `fwd backup` and `fwd restore`.
type DbArgs =
  | [<CustomCommandLine("--db-name")>] DbName of string

  interface IArgParserTemplate with
    member arg.Usage =
      match arg with
      | DbName _ -> "database name to backup; falls back to DB_NAME in current .env file"

type DbTableCountsArgs =
  | [<MainCommand; Last>] Tables of string list

  interface IArgParserTemplate with
    member arg.Usage =
      match arg with
      | Tables _ -> "list of tables to compare per env; omit to print all from current env"

type DbTablesArgs =
  | [<CustomCommandLine("-t")>] Terse

  interface IArgParserTemplate with
    member arg.Usage =
      match arg with
      | Terse -> sprintf "display name only"

[<RequireSubcommand>]
type DbCommand =
  | [<SubCommand; CliPrefix(CliPrefix.None); AltCommandLine("c")>] Counts of ParseResults<DbTableCountsArgs>
  | [<SubCommand; CliPrefix(CliPrefix.None); AltCommandLine("b")>] Backup of ParseResults<DbArgs>
  | [<SubCommand; CliPrefix(CliPrefix.None); AltCommandLine("ba")>] Backup_All
  | [<SubCommand; CliPrefix(CliPrefix.None); AltCommandLine("r")>] Restore of ParseResults<DbArgs>
  | [<SubCommand; CliPrefix(CliPrefix.None); AltCommandLine("lt")>] List_Tables of ParseResults<DbTablesArgs>

  interface IArgParserTemplate with
    member arg.Usage =
      match arg with
      | Backup _ -> "backs up the DB (by arg or env value)."
      | Backup_All -> "backs up the DB listed in each dotenv."
      | Counts _ -> "compare row counts by table for each dotenv."
      | Restore _ -> "restores a DB backup generated by backup or backup-all."
      | List_Tables _ -> "list tables in the DB (by arg or env value)."

type DbCommandFun = CommandContext.FileCommandContext -> string -> Result<Backups.BackupContext, string>

// SUBCOMMANDS
//   fwd db backup
//   fwd db backup-all
//   fwd db counts [<table>...]
//   fwd db list-tables
//   fwd db restore
// ****************************************************************************

let private fallbackToSystemEnv (key: string) =
  match Environment.getEnvironmentVariableOpt key with
  | Some(dbName) -> Ok(dbName)
  | None -> Error("Unable to resolve a DB name (no --db-name and no DB_NAME)")

let private extractDbName (cmdCtxt: CommandContext.FileCommandContext) (args: ParseResults<DbArgs>) =
  match args.TryGetResult(DbName) with
  | Some(dbName) -> Ok(dbName)
  | None ->
    match FileHelpers.actualPathToCurrentEnv cmdCtxt with
    | Error(_) -> fallbackToSystemEnv "DB_NAME"
    | Ok(path) ->
      let envVars: System.Collections.Generic.IDictionary<string, string> =
        DotEnv.Read(new DotEnvOptions(envFilePaths = [ path.FullName ]))

      match envVars.ContainsKey "DB_NAME" with
      | false -> fallbackToSystemEnv "DB_NAME"
      | true -> Ok(envVars["DB_NAME"])

let doDbCommand (dbCommand: DbCommandFun) (cmdCtxt: CommandContext.FileCommandContext) (args: ParseResults<DbArgs>) =
  args
  |> extractDbName cmdCtxt
  |> Result.bind (dbCommand cmdCtxt)
  |> OutputResult.recordResultOf

let handleBackupCommand = doDbCommand Backups.backupDb

let handleRestoreCommand = doDbCommand Backups.restoreDb

let handleBackupAllCommand (cmdCtxt: CommandContext.FileCommandContext) =
  let folder (table: Table) (item: Result<Backups.BackupContext, string>) =
    match item with
    | Ok(backupContext) -> table.AddRow([| "Ok"; backupContext.CompressedBackupPath |])
    | Error(reason) -> table.AddRow([| "Error"; reason |])

  cmdCtxt
  |> Backups.backupAllDbsAsync
  |> Async.RunSynchronously
  |> Seq.toList
  |> makeTableResult [| ""; "Output" |] folder
  |> TableResult

let private runCountsCommand (columns: string array) (bindResult: ('t) -> Counts list) (asyncCommand: Async<'t>) =
  let folder (table: Table) (item: Counts) =
    table.AddRow((item.Label :: item.Counts) |> Array.ofList)

  asyncCommand
  |> Async.RunSynchronously
  |> bindResult
  |> makeTableResult columns folder
  |> TableResult

let private doHandleTableBreakdown (commandContext: CommandContext.FileCommandContext) (tableNames: string list) =
  let columns: string array = "DotEnv" :: tableNames |> Array.ofList

  let bind (rows: Forward.MySql.Counts.DotEnvWithTableCounts array) =
    rows
    |> List.ofArray
    |> List.map (fun e ->
      { Label = e.DotEnvName
        Counts =
          e.TableCounts
          |> Seq.sortBy (fun entry -> List.findIndex (fun tName -> tName = entry.TableName) tableNames)
          |> Seq.map (fun entry -> sprintf "%i" entry.Count)
          |> List.ofSeq })

  tableNames
  |> MySql.Counts.collectTableCountsPerDotEnvAsync commandContext
  |> runCountsCommand columns bind

let private doHandleAllTableBreakdown (commandContext: CommandContext.FileCommandContext) =
  let columns: string array = [| "Table"; "Row Count" |]

  let bind (rows: Forward.MySql.Counts.CountEntry seq) =
    rows
    |> List.ofSeq
    |> List.map (fun e ->
      { Label = e.TableName
        Counts = [ (sprintf "%i" e.Count) ] })

  commandContext
  |> MySql.Counts.revisedAllTableCountsTask
  |> runCountsCommand columns bind

let handleOtherCountsCommand
  (commandContext: CommandContext.FileCommandContext)
  (args: ParseResults<DbTableCountsArgs>)
  : CommandResult<Counts> =
  match args.TryGetResult(Tables) with
  | None -> doHandleAllTableBreakdown commandContext
  | Some(tableNames) -> doHandleTableBreakdown commandContext tableNames

let handleListTablesCommand
  (commandContext: CommandContext.FileCommandContext)
  (args: ParseResults<DbTablesArgs>)
  (doPrintAndExit: (CommandResult<string>) -> int)
  =
  let columns: string array = [| "Table" |]

  let folder (table: Table) (item: string) = table.AddRow([| item |])

  let results =
    commandContext
    |> MySql.Counts.revisedAllTableCountsTask
    |> Async.RunSynchronously
    |> Seq.toList
    |> List.map _.TableName

  if args.Contains(Terse) then
    results |> ListResult |> doPrintAndExit
  else
    results |> makeTableResult columns folder |> TableResult |> doPrintAndExit

let handleDbCommand
  (context: CommandContext.FileCommandContext)
  (args: ParseResults<DbCommand>)
  (format: OutputFormat)
  (squelchError: bool)
  =
  let doPrintAndExit =
    fun (result: CommandResult<'row>) -> printAndExit format squelchError result

  match args.TryGetSubCommand() with
  | Some(Backup(args)) -> args |> handleBackupCommand context |> doPrintAndExit
  | Some(Backup_All) -> context |> handleBackupAllCommand |> doPrintAndExit
  | Some(Counts(args)) -> args |> handleOtherCountsCommand context |> doPrintAndExit
  | Some(Restore(args)) -> args |> handleRestoreCommand context |> doPrintAndExit
  | Some(List_Tables(args)) -> handleListTablesCommand context args doPrintAndExit
  | None -> ErrorResult(sprintf "Got invalid DB subcommand %O" args) |> doPrintAndExit
